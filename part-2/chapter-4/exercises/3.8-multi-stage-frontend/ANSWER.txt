# Exercise 3.8: Multi-Stage Frontend - Solution

## Task

Create a multi-stage Dockerfile for the React frontend that:
1. Uses Node.js to build the application in stage 1
2. Uses Nginx to serve static files in stage 2
3. Demonstrates significant size reduction
4. Eliminates source code and build tools from production image

## Solution Answer

### Dockerfile

```dockerfile
# Stage 1: Build stage
FROM node:16-alpine AS build-stage

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

COPY . .

RUN npm run build

# Stage 2: Production stage
FROM nginx:1.21-alpine

COPY --from=build-stage /usr/src/app/build /usr/share/nginx/html

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

## How It Works

### Stage 1: Build Stage
- **Base Image**: `node:16-alpine` (176MB)
- **Purpose**: Compile React application
- **Process**:
  - Copy package.json files
  - Run `npm install` to install dependencies
  - Copy source code
  - Run `npm run build` to create optimized build folder
- **Output**: `/usr/src/app/build/` containing static HTML/CSS/JS files
- **Discarded**: Not included in final image

### Stage 2: Production Stage
- **Base Image**: `nginx:1.21-alpine` (23MB)
- **Purpose**: Serve compiled static files
- **Process**:
  - Copy only build folder from stage 1
  - Expose port 80
  - Start Nginx server
- **Included**: Only Nginx + static assets
- **Not Included**: Node.js, npm, source code, node_modules

## Size Comparison

### Single-Stage Build (Traditional)

```dockerfile
FROM node:16-alpine

WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

EXPOSE 3000
CMD ["npm", "start"]
```

**Size**: ~250MB
- node:16-alpine: 176MB
- node_modules: 50MB
- Source code: 10MB
- Build output: 14MB

### Multi-Stage Build (This Solution)

```dockerfile
FROM node:16-alpine AS build-stage
... [build stage]

FROM nginx:1.21-alpine
COPY --from=build-stage /usr/src/app/build /usr/share/nginx/html
```

**Size**: ~35MB
- nginx:1.21-alpine: 23MB
- Static assets: 12MB

### Size Reduction

- **Before**: 250MB
- **After**: 35MB
- **Reduction**: **86%** (215MB saved)

## Key Concepts

### Multi-Stage Build Advantages

1. **Smaller Production Image**
   - Final image contains only compiled assets
   - 86% size reduction in this case
   - Faster deployment and transfers

2. **Better Security**
   - No source code in production image
   - No build tools (webpack, babel, etc.)
   - No development dependencies
   - Reduced attack surface

3. **Cleaner Separation of Concerns**
   - Build stage handles compilation
   - Runtime stage handles serving
   - Each stage has minimal responsibility

4. **No Manual Build Steps**
   - Entire build process in Docker
   - Works in CI/CD pipelines
   - Reproducible across all environments

### Stage Naming

```dockerfile
FROM node:16-alpine AS build-stage
```

The `AS build-stage` identifier allows referencing this stage in the second FROM:

```dockerfile
COPY --from=build-stage /usr/src/app/build /usr/share/nginx/html
```

### Copying Between Stages

```dockerfile
COPY --from=build-stage SOURCE_PATH DEST_PATH
```

- `--from=build-stage`: Copy from named stage
- `/usr/src/app/build`: Source in build-stage
- `/usr/share/nginx/html`: Destination in final image

## Building and Testing

### Build

```bash
docker build -t frontend:multi-stage .
```

### Run

```bash
docker run -p 8080:80 frontend:multi-stage
```

Visit http://localhost:8080 to see the application

### Verify Size

```bash
docker image ls | grep frontend:multi-stage
# Shows ~35MB
```

### View Build Layers

```bash
docker image history frontend:multi-stage --human

# Output shows:
# FROM nginx:1.21-alpine
# COPY --from=build-stage ... (12MB of assets)
```

## Single Page Application (SPA) Configuration

If using React Router, add custom Nginx configuration:

### nginx.conf

```nginx
server {
    listen 80;
    
    location / {
        root /usr/share/nginx/html;
        try_files $uri /index.html;
    }
}
```

### Updated Dockerfile

```dockerfile
FROM node:16-alpine AS build-stage

WORKDIR /usr/src/app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

FROM nginx:1.21-alpine

COPY nginx.conf /etc/nginx/nginx.conf
COPY --from=build-stage /usr/src/app/build /usr/share/nginx/html

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

This ensures all routes are handled by React Router instead of returning 404 for non-existent files.

## Advanced Examples

### Multiple Build Stages

```dockerfile
FROM node:16-alpine AS build-stage
RUN npm run build

FROM node:16-alpine AS test-stage
COPY --from=build-stage /app/build .
RUN npm run test

FROM nginx:1.21-alpine
COPY --from=test-stage /app/build /usr/share/nginx/html
```

### Using External Images as Stages

```dockerfile
FROM node:16-alpine AS build-stage
RUN npm run build

FROM python:3.9 AS docs-stage
RUN sphinx-build docs/ build/

FROM nginx:1.21-alpine
COPY --from=build-stage /app/build /usr/share/nginx/html
COPY --from=docs-stage /docs /usr/share/nginx/html/docs
```

## Comparison with Alternatives

### Option 1: Build Locally, Copy Assets

```bash
npm run build
docker build -t frontend .
```

```dockerfile
FROM nginx:1.21-alpine
COPY build/ /usr/share/nginx/html/
```

- Pros: Simplest, smallest image
- Cons: Manual steps, hard to automate, reproducibility issues

### Option 2: Multi-Stage (Recommended)

```dockerfile
FROM node:16-alpine AS build-stage
RUN npm run build

FROM nginx:1.21-alpine
COPY --from=build-stage /app/build /usr/share/nginx/html
```

- Pros: Self-contained, reproducible, works in CI/CD, proper Docker workflow
- Cons: Slightly larger intermediate image during build

### Option 3: Single-Stage Development

```dockerfile
FROM node:16-alpine
RUN npm install
COPY . .
CMD ["npm", "start"]
```

- Pros: Live reloading, development-friendly
- Cons: 250MB image, unsuitable for production

## Production Best Practices

- ✓ Use multi-stage builds for frontend applications
- ✓ Alpine variants for minimal base images
- ✓ Nginx for static file serving
- ✓ Proper SPA configuration (try_files)
- ✓ No source code in production images
- ✓ No build tools in runtime image
- ✓ Pin image versions (node:16-alpine, nginx:1.21-alpine)
- ✓ Non-root user execution (optional, for Nginx already runs as www-data)

## Troubleshooting

| Issue | Cause | Solution |
|-------|-------|----------|
| build/ folder not found | npm run build didn't execute | Verify build script in package.json |
| Files not serving | Wrong path in COPY | Ensure /usr/share/nginx/html is correct |
| 404 on React routes | Nginx doesn't know about SPA | Add try_files directive in nginx.conf |
| Build fails at npm install | Network issue or bad package | Run docker build --no-cache to retry |
| Large final image | Wrong stage used | Verify COPY --from=build-stage is correct |

## Summary

This exercise demonstrates that multi-stage builds are ideal for frontend applications because:

1. **Dramatic Size Reduction**: 86% reduction (250MB → 35MB)
2. **Production-Ready**: Only necessary files in final image
3. **Secure**: No source code or build tools exposed
4. **Automated**: Complete build process in Docker
5. **CI/CD Friendly**: Works perfectly in automated pipelines

Multi-stage builds are a best practice for containerized frontend applications and should be the default approach for production deployments.
